= *lrs*

:logo: assets/logo.png

image::{logo}[logo,float="left"]

Welcome to the home of *lrs*, a new Rust standard library to power a new
generation of Linux-based devices. *lrs* is lightweight, fast, simple, free, and
provides the full safety of the Rust programming language.

== Acknowledgements

:musl_home: http://www.musl-libc.org/ 

Our gratitude goes to the {musl_home}[musl libc] developers who not only came up
with the excellent introduction you can read above but whose open-source library
also provides a clean documentation of the Linux kernel API.

== Features

=== No unwinding

*lrs* guarantees that a sequence of function calls

----
{
    f();
    g();
    h();
}
----

executes in this order before and if the flow of control returns to the
surrounding block. This makes it much easier to reason about unsafe code and
allows us to write clearer and faster programs.

=== glibc, musl, or no libc at all

*lrs* is written directly against the Linux kernel API, meaning that it does
most of its syscalls from Rust code. The remaining libc interface that is
necessary to use the libc runtime is so small that it is almost trivial to port
it to different C libraries.

For the same reason it is feasible to use *lrs* without any libc at all.

=== Small executables

Compiling a "Hello World" statically against *lrs* and musl libc creates a
*4.5 KB* binary with no dynamic dependencies.

=== Portable

The platform-dependent part of *lrs* mirrors the *asm* and *asm-generic*
directories in the Linux kernel tree which makes it easy to port it to new
platforms. *lrs* is already available on *x86_64*, *x32*, *arm*, and *arm64*.

=== Custom allocators

Every allocating structure in *lrs* comes with an optional allocator argument.
The following allocators are currently available:

*Libc*:: Calls `malloc` and friends from the libc.
*JeMalloc*:: Calls *jemalloc*'s non-standard API with size allocations and
deallocations for better efficiency.
*NoMem*:: This dummy-allocator always reports an out-of-memory condition.
*Bda*:: The *brain-dead allocator* only allocates in multiples of the page size.
This is very useful for applications that have few allocations but whose size is
unknown at compile time and can rapidly increase.

To ease notation, all structures default to the *Heap* allocator which is an
alias for one of the allocators and can be set at compile-time. That is `Vec<T>`
is equivalent to `Vec<T, Heap>`.

The *NoMem* allocator is used to represent the state where allocating structures
are not backed by dynamic allocations but by a borrowed chunk of memory:

----
let mut buffer = [0; 100];
let mut vec: Vec<usize, NoMem> = Vec::borrowed(&mut buf);
----

Such a vector can be use normally but when the buffer is exhausted it will
report this condition back to the user:

----
println!("{:?}", vec.reserve(100));
// Err(NoMemory)
----

== License

:mpl: LICENSE

The project is licensed under the {mpl}[MPL 2.0] license. Copyright belongs to
the individual contributors.

=== tl;dr

- Can be used in proprietary projects.
- Files can be mixed with files under other licenses.
- Changes to MPL licensed files must be published under the MPL.
- Code can freely be copied and used in GPL 2.0+, AGPL 3.0+, and LGPL 2.1+
  projects.

== Logo

:simple-linux-logo: http://dablim.deviantart.com/art/Simple-Linux-Logo-336131202
:dablim: http://dablim.deviantart.com/
:ccby: http://creativecommons.org/licenses/by-sa/4.0/

The link:{logo}[logo] shows a penguin in a sprocket.

It is based on {simple-linux-logo}[Simple Linux Logo] by {dablim}[Dablim] and is
licensed under {ccby}[CC BY-SA 4.0].
