= *lrs*

:logo: assets/logo.png

image::{logo}[logo,float="left"]

lrs is a highly experimental, linux-only standard library for the rustc
compiler. It does not use any parts of the standard library that is part of the
rust distribution.

== Features

Since lrs is based on the rust compiler, it shares many features with rust
(e.g., lifetimes, borrow checking, integer overflow checking, etc.) But rustc
allows us to make significant chages to the language as long as we don't use
Mozilla's standard library. This section lists some of the differences between
rust and lrs and other features of lrs.

NOTE: In this section we'll compare programs compiled against lrs and programs
compiled against the "standard" standard library that comes with the rust
distribution. To make things simpler, we will call programs that use lrs "lrs
programs" and programs that use Mozilla's standard library "rust programs". It
should be clear from the context what is meant.

=== No unwinding

Unwinding and the `panic` macro have been removed from lrs. This means that
error handling works via return values or--in the case of unrecoverable
errors--process termination. This has the following advantages:

Potentially better performance:: Consider the following function:
+
----
fn f(a: &mut u8, b: &mut u8, g: fn()) {
    mem::swap(a, b);
    g();
    mem::swap(a, b);
}
----
+
If `g` cannot unwind, then this function can be optimized by removing both
`swap` calls. But if `g` can unwind, then the `swap` calls must stay in place
since destructors called during unwinding might access `a` and `b`.

No exception unsafety:: Consider the following (incorrect) rust code:
+
----
fn push(a: &mut Vec<T>, g: fn() -> T) {
    unsafe {
        assert!(a.capacity() > a.len());
        let len = a.len();
        a.set_len(len + 1); // <-- BUG
        ptr::write(a.as_mut_ptr().offset(len as isize), g());
    }
}
----
+
This is a naive implementation of a non-allocating `push` method on `Vec<T>`.
The code is incorrect because the length of the vector is increased before the
return value of `g` has been written to it. If `g` unwinds, the destructor of
`Vec<T>` will access the invalid value at `a[len]`, which is likely undefined
behavior. This problem does not exist in lrs. See
https://github.com/rust-lang/rfcs/pull/1236[this] (long) thread for a discussion
of exception safety in rust.

=== Small executables

:calc_url: http://is.gd/Ep2KIi

|===
|Name |lrs + glibc |lrs + musl |C |rust

|Hello World |7.0KB |4.0KB |6.5KB |436KB

|http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html[test(1)]footnote:[Note
that the different implementations do not necessarily implement the same
features.]
|18KB
|21KB
|35KB
|462KB

|{calc_url}[calc]
|9.2KB
|5.8KB
|n/a
|437KB
|===

=== glibc, musl, or no libc at all

*lrs* is written directly against the Linux kernel API, meaning that it does
most of its syscalls from Rust code. The remaining libc interface, which we have
to use to support the libc runtime, is so small that it is almost trivial to
port it to different libc implementations.

For the same reason it is feasible to use *lrs* without any libc at all.

=== Portable

The platform-dependent part of *lrs* mirrors the *asm* and *asm-generic*
directories in the Linux kernel tree which makes it easy to port it to new
platforms. *lrs* is already available on *x86_64*, *x32*, *arm*, and *arm64*.

=== Custom allocators

Every allocating structure in *lrs* comes with an optional allocator argument.
The following allocators are currently available:

*Libc*:: Calls `malloc` and friends from the libc.
*JeMalloc*:: Calls *jemalloc*'s non-standard API with sized allocations and
deallocations for higher efficiency.
*NoMem*:: This dummy-allocator always reports an out-of-memory condition.
*Bda*:: The *brain-dead allocator* only allocates in multiples of the page size.
This is very useful for applications that have few allocations but whose size is
unknown at compile time and can rapidly increase.

To ease notation, all structures default to the *Heap* allocator which is an
alias for one of the allocators and can be set at compile-time. That is,
`Vec<T>` is equivalent to `Vec<T, Heap>`.

The *NoMem* allocator is used to represent the state where allocating structures
are not backed by dynamic allocations but by a borrowed chunk of memory:

----
let mut buffer = [0u8; 200];
let mut vec: Vec<u16, NoMem> = Vec::borrowed(&mut buf);
----

Such a vector can be use normally but when the buffer is exhausted it will
report this condition back to the user:

----
println!("{:?}", vec.reserve(101));
// Err(NoMemory)
----

=== No allocations in the 99.9% case

All APIs are designed to not allocate memory in the common case. For example,
`File::open` will only allocate memory if the requested path is longer than
`PATH_MAX`. In those cases the API uses the *FbHeap*, the *fallback allocator*.
If you don't want it to allocate in those exceptional situations, set *FbHeap*
to *NoMem* at compile time.

=== Accessible development

*lrs* split into many small crates and provides the best version of incremental
compilation known to Rust developers. Compiling a single crate during
development usually takes less than a second. To this end, *lrs* comes with its
own built-system, *lrs_build*, which ensures that only the minimal amount of
work is done by the compiler.

=== Extensive Linux API coverage

The goal of *lrs* is nothing less than to provide the best and safest way to
program against the Linux kernel API.

=== Permissive licensing

:license: link:LICENSE

The whole library is licensed under the {license}[*MPL 2.0*] license which
allows static linking into proprietary programs. It is copy-left on a
file-by-file basis: Changes to files licensed under the *MPL 2.0* have to be
distributed under the same license. It also allows the code to be freely used
under several (L)GPL licenses.

=== Concise documentation

[quote, Gary Bernhardt]
We need docs in proportion to design flaws.

*lrs* docs do not try to be a Rust tutorial and are kept short and to the point,
with the expectation that most APIs are designed well enough to be understood
without any help. When appropriate, we reference Linux manual pages. On the
other hand, unsafe APIs and those that are used in unsafe code are explained in
great detail.

== Building

== Using

== Logo

:simple-linux-logo: http://dablim.deviantart.com/art/Simple-Linux-Logo-336131202
:dablim: http://dablim.deviantart.com/
:ccby: http://creativecommons.org/licenses/by-sa/4.0/

The link:{logo}[logo] shows a penguin in a sprocket.

It is based on {simple-linux-logo}[Simple Linux Logo] by {dablim}[Dablim] and is
licensed under {ccby}[CC BY-SA 4.0].
