= *lrs*

:logo: assets/logo.png

image::{logo}[logo,float="left"]

Welcome to the home of *lrs*, a new Rust standard library to power a new
generation of Linux-based devices. *lrs* is lightweight, fast, simple, free, and
provides the full safety of the Rust programming language.

== Acknowledgements

:musl_home: http://www.musl-libc.org/ 

Our gratitude goes to the {musl_home}[musl libc] developers who not only came up
with the excellent introduction you can read above but whose open-source library
also provides a clean documentation of the Linux kernel API.

== Features

=== No unwinding

*lrs* guarantees that a sequence of function calls

----
{
    f();
    g();
    h();
}
----

executes in this order before and if the flow of control returns to the
surrounding block. This makes it much easier to reason about unsafe code and
allows us to write clearer and faster programs. In particular, it fixes the
inversion of safety that existed between C and unsafe Rust code.

The presence 

=== glibc, musl, or no libc at all

*lrs* is written directly against the Linux kernel API, meaning that it does
most of its syscalls from Rust code. The remaining libc interface, which we have
to use to support the libc runtime, is so small that it is almost trivial to
port it to different libc implementations.

For the same reason it is feasible to use *lrs* without any libc at all.

=== Small executables

Compiling a "Hello World" statically against *lrs* and musl libc creates a
*4.5 KB* binary with no dynamic dependencies.

=== Portable

The platform-dependent part of *lrs* mirrors the *asm* and *asm-generic*
directories in the Linux kernel tree which makes it easy to port it to new
platforms. *lrs* is already available on *x86_64*, *x32*, *arm*, and *arm64*.

=== Custom allocators

Every allocating structure in *lrs* comes with an optional allocator argument.
The following allocators are currently available:

*Libc*:: Calls `malloc` and friends from the libc.
*JeMalloc*:: Calls *jemalloc*'s non-standard API with sized allocations and
deallocations for higher efficiency.
*NoMem*:: This dummy-allocator always reports an out-of-memory condition.
*Bda*:: The *brain-dead allocator* only allocates in multiples of the page size.
This is very useful for applications that have few allocations but whose size is
unknown at compile time and can rapidly increase.

To ease notation, all structures default to the *Heap* allocator which is an
alias for one of the allocators and can be set at compile-time. That is,
`Vec<T>` is equivalent to `Vec<T, Heap>`.

The *NoMem* allocator is used to represent the state where allocating structures
are not backed by dynamic allocations but by a borrowed chunk of memory:

----
let mut buffer = [0u8; 200];
let mut vec: Vec<u16, NoMem> = Vec::borrowed(&mut buf);
----

Such a vector can be use normally but when the buffer is exhausted it will
report this condition back to the user:

----
println!("{:?}", vec.reserve(101));
// Err(NoMemory)
----

=== No allocations in the 99.9% case

All APIs are designed to not allocate memory in the common case. For example,
`File::open` will only allocate memory if the requested path is longer than
`PATH_MAX`. In those cases the API uses the *FbHeap*, the *fallback allocator*.
If you don't want it to allocate in those exceptional situations, set *FbHeap*
to *NoMem* at compile time.

=== Accessible development

*lrs* split into many small crates and provides the best version of incremental
compilation known to Rust developers. Compiling a single crate during
development usually takes less than a second. To this end, *lrs* comes with its
own built-system, *lrs_build*, which ensures that only the minimal amount of
work is done by the compiler.

=== Extensive Linux API coverage

The goal of *lrs* is nothing less than to provide the best and safest way to
program against the Linux kernel API.

=== Permissive licensing

:license: link:LICENSE

The whole library is licensed under the {license}[*MPL 2.0*] license which
allows static linking into proprietary programs. It is copy-left on a
file-by-file basis: Changes to files licensed under the *MPL 2.0* have to be
distributed under the same license. It also allows the code to be freely used
under several (L)GPL licenses.

=== Concise documentation

[quote, Gary Bernhardt]
We need docs in proportion to design flaws.

*lrs* docs do not try to be a Rust tutorial and are kept short and to the point,
with the expectation that most APIs are designed well enough to be understood
without any help. When appropriate, we reference Linux manual pages. On the
other hand, unsafe APIs and those that are used in unsafe code are explained in
great detail.

== Building

== Using

== Logo

:simple-linux-logo: http://dablim.deviantart.com/art/Simple-Linux-Logo-336131202
:dablim: http://dablim.deviantart.com/
:ccby: http://creativecommons.org/licenses/by-sa/4.0/

The link:{logo}[logo] shows a penguin in a sprocket.

It is based on {simple-linux-logo}[Simple Linux Logo] by {dablim}[Dablim] and is
licensed under {ccby}[CC BY-SA 4.0].
